---
title: Java
date: 2020-06-22 12:36:00
tags: Java
categories: Tutorial
---

## *Sets*
* Implement containsAny for sets command.  
  - `Sets.intersection(set1, set2).isEmpty()`   
  - `CollectionUtils.containsAny(someCollection1, someCollection2)`
  - `setA.stream().anyMatch(setB::contains)`
<!-- more -->
 
 ## *NPL/empty check*
- `!getData(input).isPresent()` 
- `getData(input).isEmpty()`
---
## *Data fetching handling*
- **Solution 1**
```  
 A.getB().getC() 
```

- **Solution 2**
``` 
 Optional.ofNullable(A) 
    .map(A::getB())
    .map(B::getC())
    .orElseThrow(() -> new RuntimeException("C is not present!"));
```

---
## *Tips*
- **if - else**   
        if(x==y) {
            return a;
        } else {
            return b 
        }  
    can be simpified as:  
        x == y ? a : b 

- **if - else if - else**   
    If the conditions are not based on the same thing, for example:   
        if (condition A) {
            ...
        }
        if (condition B) {
            ...
        }  
    If the conditions is based on the same thing, then:   
        if (a > 1) {
            ...
        } else if (a == 0) {
            ...
        } else {
            ...
        }
    
- **if-else VS switch**  
    > For a **switch** statement, the **default** clause is good for error handling and testing (even it is not necessary). If it doesn't need the default clause, then **if - else** can be considered instead.

---
 ## *Regexp/ restrction annotation*

 #### Integer
`@Positive` and `@PositiveOrZero`  
 `@Min(100)` and  `@Max(100)`  


  #### String
 `@NotEmpty` // *String is not empty*  
 `@NotNull` // *String is not Null*  
 `@Size(max = 100)`  // *length of String*  
 `@Pattern(regexp = "(^[1-9]$)|(^0[1-9]|1[0-2]$)")`  // *1 - 12, include 01, 02*
 `@Pattern(regexp = "^\d{4}$")` // *Four digits*  
 `@Pattern(regexp = "[A-Z]{3}")` // *The three character ISO 4217 currency code*

 #### LocalDate
 `@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")`