---
title: Java
date: 2020-06-22 12:36:00
tags: Java
categories: Tutorial
---

## *Sets*
* Implement containsAny for sets command.  
1. `Sets.intersection(set1, set2).isEmpty()`   
2. `CollectionUtils.containsAny(someCollection1, someCollection2)`
3. `setA.stream().anyMatch(setB::contains)`
<!-- more -->
 
 ## *NPL/empty check*
1. `!getData(input).isPresent()` 
2. `getData(input).isEmpty()`
---
## *Data fetching handling*
``` 
 Solution 1: 
 A.getB().getC() 
```

``` 
 Solution 2: 
 Optional.ofNullable(A) 
    .map(A::getB())
    .map(B::getC())
    .orElseThrow(() -> new RuntimeException("C is not present!"));
```

---
## *Tips*
1. **If - else**  
```
if(x==y) return a; else return b
```
can be simpified as:
```
x == y ? a : b
``` 


2. **If - else if - else**  

If the ocnditions are not based on the same thing, for example: 
```
if (condition A) {
 ...
}

if (condition B) {
}

//do something else... 
```

If the conditions is based on the same thing, then: 
```
if (a > 1) {
  ...
} else if (a == 0) {
 ...
} else {
 ...
}
```

3. **if-else** VS **switch**  
For a **switch** statement, the **default** clause is good for error handling and testing (even it is not necessary). If it doesn't need the default clause, then **if - else** can be considered instead.

---
 # *Regexp/ restrction annotation*

 #### Integer
`@Positive` and `@PositiveOrZero`  
 `@Min(100)` and  `@Max(100)`  


  #### String
 `@NotEmpty` // *String is not empty*  
 `@NotNull` // *String is not Null*  
 `@Size(max = 100)`  // *length of String*  
 `@Pattern(regexp = "(^[1-9]$)|(^0[1-9]|1[0-2]$)")`  // *1 - 12, include 01, 02*
 `@Pattern(regexp = "^\d{4}$")` // *Four digits*  
 `@Pattern(regexp = "[A-Z]{3}")` // *The three character ISO 4217 currency code*

 #### LocalDate
 `@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")`